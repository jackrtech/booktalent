module.exports = [
"[project]/node_modules/postmark/dist/client/errors/Errors.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InvalidEmailRequestError = exports.InactiveRecipientsError = exports.ApiInputError = exports.UnknownError = exports.RateLimitExceededError = exports.ServiceUnavailablerError = exports.InternalServerError = exports.InvalidAPIKeyError = exports.HttpError = exports.PostmarkError = void 0;
/**
 * Standard Postmark error on which all sub-errors are based.
 */ var PostmarkError = function(_super) {
    __extends(PostmarkError, _super);
    function PostmarkError(message, code, statusCode) {
        if (code === void 0) {
            code = 0;
        }
        if (statusCode === void 0) {
            statusCode = 0;
        }
        var _this = _super.call(this, message) || this;
        _this.statusCode = statusCode;
        _this.code = code;
        // this is mandatory due:
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, PostmarkError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    PostmarkError.prototype.setUpStackTrace = function() {
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    };
    return PostmarkError;
}(Error);
exports.PostmarkError = PostmarkError;
var HttpError = function(_super) {
    __extends(HttpError, _super);
    function HttpError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, HttpError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return HttpError;
}(PostmarkError);
exports.HttpError = HttpError;
var InvalidAPIKeyError = function(_super) {
    __extends(InvalidAPIKeyError, _super);
    function InvalidAPIKeyError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, InvalidAPIKeyError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return InvalidAPIKeyError;
}(HttpError);
exports.InvalidAPIKeyError = InvalidAPIKeyError;
var InternalServerError = function(_super) {
    __extends(InternalServerError, _super);
    function InternalServerError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, InternalServerError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return InternalServerError;
}(HttpError);
exports.InternalServerError = InternalServerError;
var ServiceUnavailablerError = function(_super) {
    __extends(ServiceUnavailablerError, _super);
    function ServiceUnavailablerError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, ServiceUnavailablerError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return ServiceUnavailablerError;
}(HttpError);
exports.ServiceUnavailablerError = ServiceUnavailablerError;
var RateLimitExceededError = function(_super) {
    __extends(RateLimitExceededError, _super);
    function RateLimitExceededError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, RateLimitExceededError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return RateLimitExceededError;
}(HttpError);
exports.RateLimitExceededError = RateLimitExceededError;
var UnknownError = function(_super) {
    __extends(UnknownError, _super);
    function UnknownError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, UnknownError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return UnknownError;
}(HttpError);
exports.UnknownError = UnknownError;
var ApiInputError = function(_super) {
    __extends(ApiInputError, _super);
    function ApiInputError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, ApiInputError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    ApiInputError.buildSpecificError = function(message, code, statusCode) {
        switch(code){
            case this.ERROR_CODES.inactiveRecipient:
                return new InactiveRecipientsError(message, code, statusCode);
            case this.ERROR_CODES.invalidEmailRequest:
                return new InvalidEmailRequestError(message, code, statusCode);
            default:
                return new ApiInputError(message, code, statusCode);
        }
    };
    ApiInputError.ERROR_CODES = {
        inactiveRecipient: 406,
        invalidEmailRequest: 300
    };
    return ApiInputError;
}(HttpError);
exports.ApiInputError = ApiInputError;
var InactiveRecipientsError = function(_super) {
    __extends(InactiveRecipientsError, _super);
    function InactiveRecipientsError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, InactiveRecipientsError.prototype);
        _this.setUpStackTrace();
        _this.recipients = InactiveRecipientsError.parseInactiveRecipients(message);
        return _this;
    }
    InactiveRecipientsError.parseInactiveRecipients = function(message) {
        var result = [];
        this.inactiveRecipientsPatterns.some(function(pattern) {
            var regexResult = message.match(pattern);
            if (regexResult !== null) {
                result = regexResult[1].split(',').map(function(element) {
                    return element.trim();
                });
                return result;
            } else {
                result = [];
            }
        });
        return result;
    };
    InactiveRecipientsError.inactiveRecipientsPatterns = [
        /Found inactive addresses: (.+?)\.? Inactive/,
        /these inactive addresses: (.+?)\.?$/
    ];
    return InactiveRecipientsError;
}(ApiInputError);
exports.InactiveRecipientsError = InactiveRecipientsError;
var InvalidEmailRequestError = function(_super) {
    __extends(InvalidEmailRequestError, _super);
    function InvalidEmailRequestError(message, code, statusCode) {
        var _this = _super.call(this, message, code, statusCode) || this;
        Object.setPrototypeOf(_this, InvalidEmailRequestError.prototype);
        _this.setUpStackTrace();
        return _this;
    }
    return InvalidEmailRequestError;
}(ApiInputError);
exports.InvalidEmailRequestError = InvalidEmailRequestError; //# sourceMappingURL=Errors.js.map
}),
"[project]/node_modules/postmark/dist/client/errors/ErrorHandler.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ErrorHandler = void 0;
var Errors = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/errors/Errors.js [app-rsc] (ecmascript)");
/**
 * Handles general errors and all client request errors.
 * Client response errors are classified so that proper response error is generated.
 */ var ErrorHandler = function() {
    function ErrorHandler() {}
    /**
     * Build general Postmark error.
     *
     * @param errorMessage - error message that needs to be identified and transformed to proper Postmark error.
     *
     * @returns properly formatted Postmark error.
     */ ErrorHandler.prototype.buildError = function(errorMessage, code, statusCode) {
        if (code === void 0) {
            code = 0;
        }
        if (statusCode === void 0) {
            statusCode = 0;
        }
        if (statusCode === 0 && code === 0) {
            return new Errors.PostmarkError(errorMessage);
        } else {
            return this.buildErrorByHttpStatusCode(errorMessage, code, statusCode);
        }
    };
    /**
     * Build Postmark error based on HTTP request status.
     *
     * @param error - http request library error, that will be transformed to Postmark error.
     *
     * @returns properly formatted Postmark error.
     */ ErrorHandler.prototype.buildErrorByHttpStatusCode = function(errorMessage, errorCode, errorStatusCode) {
        switch(errorStatusCode){
            case 401:
                return new Errors.InvalidAPIKeyError(errorMessage, errorCode, errorStatusCode);
            case 404:
                return new Errors.PostmarkError(errorMessage, errorCode, errorStatusCode);
            case 422:
                return Errors.ApiInputError.buildSpecificError(errorMessage, errorCode, errorStatusCode);
            case 429:
                return new Errors.RateLimitExceededError(errorMessage, errorCode, errorStatusCode);
            case 500:
                return new Errors.InternalServerError(errorMessage, errorCode, errorStatusCode);
            case 503:
                return new Errors.ServiceUnavailablerError(errorMessage, errorCode, errorStatusCode);
            default:
                return new Errors.UnknownError(errorMessage, errorCode, errorStatusCode);
        }
    };
    return ErrorHandler;
}();
exports.ErrorHandler = ErrorHandler; //# sourceMappingURL=ErrorHandler.js.map
}),
"[project]/node_modules/postmark/dist/client/models/client/ClientOptions.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ClientOptions = void 0;
var ClientOptions;
(function(ClientOptions) {
    var Configuration = function() {
        function Configuration(useHttps, requestHost, timeout) {
            this.useHttps = useHttps;
            this.requestHost = requestHost;
            this.timeout = timeout;
        }
        return Configuration;
    }();
    ClientOptions.Configuration = Configuration;
    var HttpMethod;
    (function(HttpMethod) {
        HttpMethod["GET"] = "GET";
        HttpMethod["POST"] = "POST";
        HttpMethod["DELETE"] = "DELETE";
        HttpMethod["PUT"] = "PUT";
        HttpMethod["OPTIONS"] = "OPTIONS";
        HttpMethod["HEAD"] = "HEAD";
        HttpMethod["PATCH"] = "PATCH";
    })(HttpMethod = ClientOptions.HttpMethod || (ClientOptions.HttpMethod = {}));
    var AuthHeaderNames;
    (function(AuthHeaderNames) {
        AuthHeaderNames["SERVER_TOKEN"] = "X-Postmark-Server-Token";
        AuthHeaderNames["ACCOUNT_TOKEN"] = "X-Postmark-Account-Token";
    })(AuthHeaderNames = ClientOptions.AuthHeaderNames || (ClientOptions.AuthHeaderNames = {}));
})(ClientOptions = exports.ClientOptions || (exports.ClientOptions = {})); //# sourceMappingURL=ClientOptions.js.map
}),
"[project]/node_modules/postmark/dist/client/models/client/SupportingTypes.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=SupportingTypes.js.map
}),
"[project]/node_modules/postmark/dist/client/models/client/HttpClient.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpClient = void 0;
var HttpClient = function() {
    function HttpClient(configOptions) {
        this.clientOptions = __assign(__assign({}, HttpClient.DefaultOptions), configOptions);
        this.initHttpClient(this.clientOptions);
    }
    HttpClient.prototype.getBaseHttpRequestURL = function() {
        var scheme = this.clientOptions.useHttps ? "https" : "http";
        return "".concat(scheme, "://").concat(this.clientOptions.requestHost);
    };
    /**
     * Http Client connection configuration options.
     * You may modify these values and new clients will use them.
     * Any values provided to a Client constructor will override default options.
     */ HttpClient.DefaultOptions = {
        useHttps: true,
        requestHost: "api.postmarkapp.com",
        timeout: 180
    };
    return HttpClient;
}();
exports.HttpClient = HttpClient; //# sourceMappingURL=HttpClient.js.map
}),
"[project]/node_modules/postmark/dist/client/models/client/Callback.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=Callback.js.map
}),
"[project]/node_modules/postmark/dist/client/models/client/DefaultResponse.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=DefaultResponse.js.map
}),
"[project]/node_modules/postmark/dist/client/models/client/FilteringParameters.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FilteringParameters = void 0;
/**
 * Describes default filtering parameters that can be used.
 * When pagination parameters are not specified, default values are set.
 */ var FilteringParameters = function() {
    function FilteringParameters(count, offset) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        this.count = count;
        this.offset = offset;
    }
    return FilteringParameters;
}();
exports.FilteringParameters = FilteringParameters; //# sourceMappingURL=FilteringParameters.js.map
}),
"[project]/node_modules/postmark/dist/client/models/bounces/Bounce.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BounceTypeCode = exports.BounceType = void 0;
var BounceType;
(function(BounceType) {
    BounceType["HardBounce"] = "HardBounce";
    BounceType["Transient"] = "Transient";
    BounceType["Unsubscribe"] = "Unsubscribe";
    BounceType["Subscribe"] = "Subscribe";
    BounceType["AutoResponder"] = "AutoResponder";
    BounceType["AddressChange"] = "AddressChange";
    BounceType["DnsError"] = "DnsError";
    BounceType["SpamNotification"] = "SpamNotification";
    BounceType["OpenRelayTest"] = "OpenRelayTest";
    BounceType["Unknown"] = "Unknown";
    BounceType["SoftBounce"] = "SoftBounce";
    BounceType["VirusNotification"] = "VirusNotification";
    BounceType["ChallengeVerification"] = "ChallengeVerification";
    BounceType["BadEmailAddress"] = "BadEmailAddress";
    BounceType["SpamComplaint"] = "SpamComplaint";
    BounceType["ManuallyDeactivated"] = "ManuallyDeactivated";
    BounceType["Unconfirmed"] = "Unconfirmed";
    BounceType["Blocked"] = "Blocked";
    BounceType["SMTPApiError"] = "SMTPApiError";
    BounceType["InboundError"] = "InboundError";
    BounceType["DMARCPolicy"] = "DMARCPolicy";
    BounceType["TemplateRenderingFailed"] = "TemplateRenderingFailed";
})(BounceType = exports.BounceType || (exports.BounceType = {}));
var BounceTypeCode;
(function(BounceTypeCode) {
    BounceTypeCode[BounceTypeCode["HardBounce"] = 1] = "HardBounce";
    BounceTypeCode[BounceTypeCode["Transient"] = 2] = "Transient";
    BounceTypeCode[BounceTypeCode["Unsubscribe"] = 16] = "Unsubscribe";
    BounceTypeCode[BounceTypeCode["Subscribe"] = 32] = "Subscribe";
    BounceTypeCode[BounceTypeCode["AutoResponder"] = 64] = "AutoResponder";
    BounceTypeCode[BounceTypeCode["AddressChange"] = 128] = "AddressChange";
    BounceTypeCode[BounceTypeCode["DnsError"] = 256] = "DnsError";
    BounceTypeCode[BounceTypeCode["SpamNotification"] = 512] = "SpamNotification";
    BounceTypeCode[BounceTypeCode["OpenRelayTest"] = 1024] = "OpenRelayTest";
    BounceTypeCode[BounceTypeCode["Unknown"] = 2048] = "Unknown";
    BounceTypeCode[BounceTypeCode["SoftBounce"] = 4096] = "SoftBounce";
    BounceTypeCode[BounceTypeCode["VirusNotification"] = 8192] = "VirusNotification";
    BounceTypeCode[BounceTypeCode["ChallengeVerification"] = 16384] = "ChallengeVerification";
    BounceTypeCode[BounceTypeCode["BadEmailAddress"] = 100000] = "BadEmailAddress";
    BounceTypeCode[BounceTypeCode["SpamComplaint"] = 100001] = "SpamComplaint";
    BounceTypeCode[BounceTypeCode["ManuallyDeactivated"] = 100002] = "ManuallyDeactivated";
    BounceTypeCode[BounceTypeCode["Unconfirmed"] = 100003] = "Unconfirmed";
    BounceTypeCode[BounceTypeCode["Blocked"] = 100006] = "Blocked";
    BounceTypeCode[BounceTypeCode["SMTPApiError"] = 100007] = "SMTPApiError";
    BounceTypeCode[BounceTypeCode["InboundError"] = 100008] = "InboundError";
    BounceTypeCode[BounceTypeCode["DMARCPolicy"] = 100009] = "DMARCPolicy";
    BounceTypeCode[BounceTypeCode["TemplateRenderingFailed"] = 100010] = "TemplateRenderingFailed";
})(BounceTypeCode = exports.BounceTypeCode || (exports.BounceTypeCode = {})); //# sourceMappingURL=Bounce.js.map
}),
"[project]/node_modules/postmark/dist/client/models/bounces/BounceFilteringParameters.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BounceFilteringParameters = void 0;
var FilteringParameters_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/FilteringParameters.js [app-rsc] (ecmascript)");
/**
 * Describes filtering parameters that can be used when retrieving bounces.
 * When pagination parameters are not specified, default values are set.
 */ var BounceFilteringParameters = function(_super) {
    __extends(BounceFilteringParameters, _super);
    function BounceFilteringParameters(count, offset, type, inactive, emailFilter, tag, messageID, fromDate, toDate, messageStream) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.type = type;
        _this.inactive = inactive;
        _this.emailFilter = emailFilter;
        _this.tag = tag;
        _this.messageID = messageID;
        _this.fromDate = fromDate;
        _this.toDate = toDate;
        _this.messageStream = messageStream;
        return _this;
    }
    return BounceFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.BounceFilteringParameters = BounceFilteringParameters; //# sourceMappingURL=BounceFilteringParameters.js.map
}),
"[project]/node_modules/postmark/dist/client/models/message/Message.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Message = void 0;
var Message = function() {
    function Message(From, Subject, HtmlBody, TextBody, To, Cc, Bcc, ReplyTo, Tag, TrackOpens, TrackLinks, Headers, Attachments, Metadata) {
        this.From = From;
        this.To = To;
        this.Cc = Cc;
        this.Bcc = Bcc;
        this.Subject = Subject;
        this.ReplyTo = ReplyTo;
        this.HtmlBody = HtmlBody;
        this.TextBody = TextBody;
        this.Tag = Tag;
        this.TrackOpens = TrackOpens;
        this.TrackLinks = TrackLinks;
        this.Headers = Headers;
        this.Attachments = Attachments;
        this.Metadata = Metadata;
    }
    return Message;
}();
exports.Message = Message; //# sourceMappingURL=Message.js.map
}),
"[project]/node_modules/postmark/dist/client/models/message/SupportingTypes.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Attachment = exports.Header = exports.ServerDeliveryTypes = exports.LinkClickLocation = exports.LinkTrackingOptions = void 0;
var LinkTrackingOptions;
(function(LinkTrackingOptions) {
    LinkTrackingOptions["TextOnly"] = "TextOnly";
    LinkTrackingOptions["HtmlOnly"] = "HtmlOnly";
    LinkTrackingOptions["HtmlAndText"] = "HtmlAndText";
    LinkTrackingOptions["None"] = "None";
})(LinkTrackingOptions = exports.LinkTrackingOptions || (exports.LinkTrackingOptions = {}));
var LinkClickLocation;
(function(LinkClickLocation) {
    LinkClickLocation["HTML"] = "HTML";
    LinkClickLocation["Text"] = "Text";
})(LinkClickLocation = exports.LinkClickLocation || (exports.LinkClickLocation = {}));
var ServerDeliveryTypes;
(function(ServerDeliveryTypes) {
    ServerDeliveryTypes["Live"] = "Live";
    ServerDeliveryTypes["Sandbox"] = "Sandbox";
})(ServerDeliveryTypes = exports.ServerDeliveryTypes || (exports.ServerDeliveryTypes = {}));
var Header = function() {
    function Header(Name, Value) {
        this.Name = Name;
        this.Value = Value;
    }
    return Header;
}();
exports.Header = Header;
/**
 * Attachment content
 *
 * @param Name - name of the attachment, for example book.pdf
 * @param Content - Base64 encoded content, for example: fs.readFileSync('/Folder/book.pdf').toString('base64')
 * @param ContentID - id of the attachment, in case we are referencing it, for example: cid:123book.pdf
 * @param ContentType - content type (json, image, etc)
 * @param ContentLength - length of the message
 */ var Attachment = function() {
    function Attachment(Name, Content, ContentType, ContentID, ContentLength, Disposition) {
        if (ContentID === void 0) {
            ContentID = null;
        }
        this.Name = Name;
        this.Content = Content;
        this.ContentType = ContentType;
        this.ContentID = ContentID;
        this.ContentLength = ContentLength;
        this.Disposition = Disposition;
    }
    return Attachment;
}();
exports.Attachment = Attachment; //# sourceMappingURL=SupportingTypes.js.map
}),
"[project]/node_modules/postmark/dist/client/models/messages/OutboundMessage.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=OutboundMessage.js.map
}),
"[project]/node_modules/postmark/dist/client/models/messages/OutboundMessageOpen.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=OutboundMessageOpen.js.map
}),
"[project]/node_modules/postmark/dist/client/models/messages/OutboundMessageClick.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=OutboundMessageClick.js.map
}),
"[project]/node_modules/postmark/dist/client/models/messages/InboundMessage.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=InboundMessage.js.map
}),
"[project]/node_modules/postmark/dist/client/models/messages/MessageFilteringParameters.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OutboundMessageClicksFilteringParameters = exports.OutboundMessageOpensFilteringParameters = exports.OutboundMessageTrackingFilteringParameters = exports.InboundMessagesFilteringParameters = exports.OutboundMessagesFilteringParameters = exports.InboundMessageStatus = exports.OutboundMessageStatus = void 0;
var FilteringParameters_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/FilteringParameters.js [app-rsc] (ecmascript)");
var OutboundMessageStatus;
(function(OutboundMessageStatus) {
    OutboundMessageStatus["Queued"] = "queued";
    OutboundMessageStatus["Sent"] = "sent";
    OutboundMessageStatus["Processed"] = "processed";
})(OutboundMessageStatus = exports.OutboundMessageStatus || (exports.OutboundMessageStatus = {}));
var InboundMessageStatus;
(function(InboundMessageStatus) {
    InboundMessageStatus["Queued"] = "queued";
    InboundMessageStatus["Sent"] = "sent";
    InboundMessageStatus["Processed"] = "processed";
    InboundMessageStatus["Blocked"] = "blocked";
    InboundMessageStatus["Failed"] = "failed";
    InboundMessageStatus["Scheduled"] = "scheduled";
})(InboundMessageStatus = exports.InboundMessageStatus || (exports.InboundMessageStatus = {}));
/**
 * Describes filtering parameters that can be used when retrieving outbound messages.
 * When pagination parameters are not specified, default values are set.
 */ var OutboundMessagesFilteringParameters = function(_super) {
    __extends(OutboundMessagesFilteringParameters, _super);
    function OutboundMessagesFilteringParameters(count, offset, recipient, fromEmail, tag, status, fromDate, toDate, subject, messageStream) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.recipient = recipient;
        _this.fromEmail = fromEmail;
        _this.tag = tag;
        _this.status = status;
        _this.fromDate = fromDate;
        _this.toDate = toDate;
        _this.subject = subject;
        _this.messageStream = messageStream;
        return _this;
    }
    return OutboundMessagesFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.OutboundMessagesFilteringParameters = OutboundMessagesFilteringParameters;
/**
 * Describes filtering parameters that can be used when retrieving inbound messages.
 * When pagination parameters are not specified, default values are set.
 */ var InboundMessagesFilteringParameters = function(_super) {
    __extends(InboundMessagesFilteringParameters, _super);
    function InboundMessagesFilteringParameters(count, offset, mailboxHash, recipient, fromEmail, tag, status, fromDate, toDate, subject) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.status = status;
        _this.mailboxHash = mailboxHash;
        _this.recipient = recipient;
        _this.fromEmail = fromEmail;
        _this.tag = tag;
        _this.fromDate = fromDate;
        _this.toDate = toDate;
        _this.subject = subject;
        return _this;
    }
    return InboundMessagesFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.InboundMessagesFilteringParameters = InboundMessagesFilteringParameters;
/**
 * Describes filtering parameters that can be used when retrieving tracked outbound messages.
 * When pagination parameters are not specified, default values are set.
 */ var OutboundMessageTrackingFilteringParameters = function(_super) {
    __extends(OutboundMessageTrackingFilteringParameters, _super);
    function OutboundMessageTrackingFilteringParameters(count, offset, recipient, tag, client_name, client_company, client_family, os_name, os_family, os_company, platform, country, region, city, messageStream) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.recipient = recipient;
        _this.tag = tag;
        _this.client_name = client_name;
        _this.client_company = client_company;
        _this.client_family = client_family;
        _this.os_name = os_name;
        _this.os_family = os_family;
        _this.os_company = os_company;
        _this.platform = platform;
        _this.country = country;
        _this.region = region;
        _this.city = city;
        _this.messageStream = messageStream;
        return _this;
    }
    return OutboundMessageTrackingFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.OutboundMessageTrackingFilteringParameters = OutboundMessageTrackingFilteringParameters;
var OutboundMessageOpensFilteringParameters = function(_super) {
    __extends(OutboundMessageOpensFilteringParameters, _super);
    function OutboundMessageOpensFilteringParameters() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return OutboundMessageOpensFilteringParameters;
}(OutboundMessageTrackingFilteringParameters);
exports.OutboundMessageOpensFilteringParameters = OutboundMessageOpensFilteringParameters;
var OutboundMessageClicksFilteringParameters = function(_super) {
    __extends(OutboundMessageClicksFilteringParameters, _super);
    function OutboundMessageClicksFilteringParameters() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return OutboundMessageClicksFilteringParameters;
}(OutboundMessageTrackingFilteringParameters);
exports.OutboundMessageClicksFilteringParameters = OutboundMessageClicksFilteringParameters; //# sourceMappingURL=MessageFilteringParameters.js.map
}),
"[project]/node_modules/postmark/dist/client/models/templates/Template.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TemplateFilteringParameters = exports.TemplatedMessage = exports.TemplatesPushRequest = exports.TemplateTypes = exports.TemplateValidationOptions = exports.CreateTemplateRequest = exports.UpdateTemplateRequest = void 0;
var FilteringParameters_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/FilteringParameters.js [app-rsc] (ecmascript)");
var UpdateTemplateRequest = function() {
    function UpdateTemplateRequest(Name, Subject, HtmlBody, TextBody, Alias, TemplateType, LayoutTemplate) {
        this.Name = Name;
        this.Subject = Subject;
        this.HtmlBody = HtmlBody;
        this.TextBody = TextBody;
        this.Alias = Alias;
        this.LayoutTemplate = LayoutTemplate;
        this.TemplateType = TemplateType;
    }
    return UpdateTemplateRequest;
}();
exports.UpdateTemplateRequest = UpdateTemplateRequest;
var CreateTemplateRequest = function(_super) {
    __extends(CreateTemplateRequest, _super);
    function CreateTemplateRequest(Name, Subject, HtmlBody, TextBody, Alias, TemplateType, LayoutTemplate) {
        return _super.call(this, Name, Subject, HtmlBody, TextBody, Alias, TemplateType, LayoutTemplate) || this;
    }
    return CreateTemplateRequest;
}(UpdateTemplateRequest);
exports.CreateTemplateRequest = CreateTemplateRequest;
var TemplateValidationOptions = function() {
    function TemplateValidationOptions(Subject, HtmlBody, TextBody, TestRenderModel, TemplateType, LayoutTemplate, InlineCssForHtmlTestRender) {
        this.Subject = Subject;
        this.HtmlBody = HtmlBody;
        this.TextBody = TextBody;
        this.TestRenderModel = TestRenderModel;
        this.TemplateType = TemplateType;
        this.LayoutTemplate = LayoutTemplate;
        this.InlineCssForHtmlTestRender = InlineCssForHtmlTestRender;
    }
    return TemplateValidationOptions;
}();
exports.TemplateValidationOptions = TemplateValidationOptions;
var TemplateTypes;
(function(TemplateTypes) {
    TemplateTypes["Standard"] = "Standard";
    TemplateTypes["Layout"] = "Layout";
})(TemplateTypes = exports.TemplateTypes || (exports.TemplateTypes = {}));
var TemplatesPushRequest = function() {
    function TemplatesPushRequest(SourceServerID, DestinationServerID, PerformChanges) {
        this.SourceServerID = SourceServerID;
        this.DestinationServerID = DestinationServerID;
        this.PerformChanges = PerformChanges;
    }
    return TemplatesPushRequest;
}();
exports.TemplatesPushRequest = TemplatesPushRequest;
var TemplatedMessage = function() {
    function TemplatedMessage(from, templateIdOrAlias, templateModel, to, cc, bcc, replyTo, tag, trackOpens, trackLinks, headers, attachments) {
        this.From = from;
        this.TemplateModel = templateModel;
        if (typeof templateIdOrAlias === "number") {
            this.TemplateId = templateIdOrAlias;
        } else {
            this.TemplateAlias = templateIdOrAlias;
        }
        this.To = to;
        this.Cc = cc;
        this.Bcc = bcc;
        this.ReplyTo = replyTo;
        this.Tag = tag;
        this.TrackOpens = trackOpens;
        this.TrackLinks = trackLinks;
        this.Headers = headers;
        this.Attachments = attachments;
    }
    return TemplatedMessage;
}();
exports.TemplatedMessage = TemplatedMessage;
/**
 * Describes filtering parameters that can be used when retrieving templates.
 * When pagination parameters are not specified, default values are set.
 */ var TemplateFilteringParameters = function(_super) {
    __extends(TemplateFilteringParameters, _super);
    function TemplateFilteringParameters(count, offset, templateType, layoutTemplate) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.templateType = templateType;
        _this.layoutTemplate = layoutTemplate;
        return _this;
    }
    return TemplateFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.TemplateFilteringParameters = TemplateFilteringParameters; //# sourceMappingURL=Template.js.map
}),
"[project]/node_modules/postmark/dist/client/models/server/Server.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateServerRequest = exports.UpdateServerRequest = void 0;
var UpdateServerRequest = function() {
    function UpdateServerRequest(Name, Color, SmtpApiActivated, RawEmailEnabled, InboundHookUrl, BounceHookUrl, OpenHookUrl, DeliveryHookUrl, ClickHookUrl, PostFirstOpenOnly, InboundSpamThreshold, TrackOpens, TrackLinks, IncludeBounceContentInHook, EnableSmtpApiErrorHooks, InboundDomain) {
        this.Name = Name;
        this.Color = Color;
        this.SmtpApiActivated = SmtpApiActivated;
        this.RawEmailEnabled = RawEmailEnabled;
        this.InboundHookUrl = InboundHookUrl;
        this.BounceHookUrl = BounceHookUrl;
        this.OpenHookUrl = OpenHookUrl;
        this.DeliveryHookUrl = DeliveryHookUrl;
        this.ClickHookUrl = ClickHookUrl;
        this.PostFirstOpenOnly = PostFirstOpenOnly;
        this.InboundSpamThreshold = InboundSpamThreshold;
        this.InboundDomain = InboundDomain;
        this.TrackOpens = TrackOpens;
        this.TrackLinks = TrackLinks;
        this.IncludeBounceContentInHook = IncludeBounceContentInHook;
        this.EnableSmtpApiErrorHooks = EnableSmtpApiErrorHooks;
    }
    return UpdateServerRequest;
}();
exports.UpdateServerRequest = UpdateServerRequest;
var CreateServerRequest = function(_super) {
    __extends(CreateServerRequest, _super);
    function CreateServerRequest(Name, Color, SmtpApiActivated, RawEmailEnabled, InboundHookUrl, BounceHookUrl, OpenHookUrl, DeliveryHookUrl, ClickHookUrl, PostFirstOpenOnly, InboundSpamThreshold, TrackOpens, TrackLinks, IncludeBounceContentInHook, EnableSmtpApiErrorHooks, InboundDomain, DeliveryType) {
        var _this = _super.call(this, Name, Color, SmtpApiActivated, RawEmailEnabled, InboundHookUrl, BounceHookUrl, OpenHookUrl, DeliveryHookUrl, ClickHookUrl, PostFirstOpenOnly, InboundSpamThreshold, TrackOpens, TrackLinks, IncludeBounceContentInHook, EnableSmtpApiErrorHooks, InboundDomain) || this;
        _this.DeliveryType = DeliveryType;
        return _this;
    }
    return CreateServerRequest;
}(UpdateServerRequest);
exports.CreateServerRequest = CreateServerRequest; //# sourceMappingURL=Server.js.map
}),
"[project]/node_modules/postmark/dist/client/models/server/Servers.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=Servers.js.map
}),
"[project]/node_modules/postmark/dist/client/models/server/ServerFilteringParameters.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServerFilteringParameters = void 0;
var FilteringParameters_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/FilteringParameters.js [app-rsc] (ecmascript)");
/**
 * Describes filtering parameters that can be used when retrieving servers.
 * When pagination parameters are not specified, default values are set.
 */ var ServerFilteringParameters = function(_super) {
    __extends(ServerFilteringParameters, _super);
    function ServerFilteringParameters(count, offset, name) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.name = name;
        return _this;
    }
    return ServerFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.ServerFilteringParameters = ServerFilteringParameters; //# sourceMappingURL=ServerFilteringParameters.js.map
}),
"[project]/node_modules/postmark/dist/client/models/domains/Domain.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateDomainRequest = exports.CreateDomainRequest = void 0;
var CreateDomainRequest = function() {
    function CreateDomainRequest(Name, ReturnPathDomain) {
        this.Name = Name;
        this.ReturnPathDomain = ReturnPathDomain;
    }
    return CreateDomainRequest;
}();
exports.CreateDomainRequest = CreateDomainRequest;
var UpdateDomainRequest = function() {
    function UpdateDomainRequest(ReturnPathDomain) {
        this.ReturnPathDomain = ReturnPathDomain;
    }
    return UpdateDomainRequest;
}();
exports.UpdateDomainRequest = UpdateDomainRequest; //# sourceMappingURL=Domain.js.map
}),
"[project]/node_modules/postmark/dist/client/models/senders/Signature.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateSignatureRequest = exports.UpdateSignatureRequest = void 0;
var UpdateSignatureRequest = function() {
    function UpdateSignatureRequest(Name, ReplyToEmail, ReturnPathDomain, ConfirmationPersonalNote) {
        this.Name = Name;
        this.ReplyToEmail = ReplyToEmail;
        this.ReturnPathDomain = ReturnPathDomain;
        this.ConfirmationPersonalNote = ConfirmationPersonalNote;
    }
    return UpdateSignatureRequest;
}();
exports.UpdateSignatureRequest = UpdateSignatureRequest;
var CreateSignatureRequest = function() {
    function CreateSignatureRequest(Name, FromEmail, ReplyToEmail, ReturnPathDomain, ConfirmationPersonalNote) {
        this.Name = Name;
        this.ReplyToEmail = ReplyToEmail;
        this.ReturnPathDomain = ReturnPathDomain;
        this.FromEmail = FromEmail;
        this.ConfirmationPersonalNote = ConfirmationPersonalNote;
    }
    return CreateSignatureRequest;
}();
exports.CreateSignatureRequest = CreateSignatureRequest; //# sourceMappingURL=Signature.js.map
}),
"[project]/node_modules/postmark/dist/client/models/suppressions/Suppression.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=Suppression.js.map
}),
"[project]/node_modules/postmark/dist/client/models/stats/Stats.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=Stats.js.map
}),
"[project]/node_modules/postmark/dist/client/models/stats/StatsFilteringParameters.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StatisticsFilteringParameters = void 0;
var StatisticsFilteringParameters = function() {
    function StatisticsFilteringParameters(tag, fromDate, toDate, messageStream) {
        this.tag = tag;
        this.fromDate = fromDate;
        this.toDate = toDate;
        this.messageStream = messageStream;
    }
    return StatisticsFilteringParameters;
}();
exports.StatisticsFilteringParameters = StatisticsFilteringParameters; //# sourceMappingURL=StatsFilteringParameters.js.map
}),
"[project]/node_modules/postmark/dist/client/models/triggers/InboundRule.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateInboundRuleRequest = void 0;
var CreateInboundRuleRequest = function() {
    function CreateInboundRuleRequest(Rule) {
        this.Rule = Rule;
    }
    return CreateInboundRuleRequest;
}();
exports.CreateInboundRuleRequest = CreateInboundRuleRequest; //# sourceMappingURL=InboundRule.js.map
}),
"[project]/node_modules/postmark/dist/client/models/webhooks/Webhooks.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=Webhooks.js.map
}),
"[project]/node_modules/postmark/dist/client/models/webhooks/Webhook.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateWebhookRequest = exports.UpdateWebhookRequest = void 0;
var UpdateWebhookRequest = function() {
    function UpdateWebhookRequest(url, triggers, httpAuth, httpHeaders) {
        this.Url = url;
        this.HttpAuth = httpAuth;
        this.HttpHeaders = httpHeaders;
        this.Triggers = triggers;
    }
    return UpdateWebhookRequest;
}();
exports.UpdateWebhookRequest = UpdateWebhookRequest;
var CreateWebhookRequest = function(_super) {
    __extends(CreateWebhookRequest, _super);
    function CreateWebhookRequest(url, triggers, httpAuth, httpHeaders, messageStream) {
        var _this = _super.call(this, url, triggers, httpAuth, httpHeaders) || this;
        _this.MessageStream = messageStream;
        return _this;
    }
    return CreateWebhookRequest;
}(UpdateWebhookRequest);
exports.CreateWebhookRequest = CreateWebhookRequest; //# sourceMappingURL=Webhook.js.map
}),
"[project]/node_modules/postmark/dist/client/models/webhooks/WebhookFilteringParameters.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebhookFilteringParameters = void 0;
/**
 * Describes filtering parameters that can be used when retrieving webhooks.
 */ var WebhookFilteringParameters = function() {
    function WebhookFilteringParameters(messageStream) {
        this.messageStream = messageStream;
    }
    return WebhookFilteringParameters;
}();
exports.WebhookFilteringParameters = WebhookFilteringParameters; //# sourceMappingURL=WebhookFilteringParameters.js.map
}),
"[project]/node_modules/postmark/dist/client/models/webhooks/payload/BounceWebhook.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=BounceWebhook.js.map
}),
"[project]/node_modules/postmark/dist/client/models/webhooks/payload/DeliveryWebhook.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=DeliveryWebhook.js.map
}),
"[project]/node_modules/postmark/dist/client/models/webhooks/payload/SpamComplaintWebhook.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=SpamComplaintWebhook.js.map
}),
"[project]/node_modules/postmark/dist/client/models/webhooks/payload/ClickWebhook.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=ClickWebhook.js.map
}),
"[project]/node_modules/postmark/dist/client/models/webhooks/payload/OpenWebhook.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=OpenWebhook.js.map
}),
"[project]/node_modules/postmark/dist/client/models/webhooks/payload/SubscriptionChangeWebhook.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=SubscriptionChangeWebhook.js.map
}),
"[project]/node_modules/postmark/dist/client/models/webhooks/payload/InboundWebhook.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=InboundWebhook.js.map
}),
"[project]/node_modules/postmark/dist/client/models/suppressions/SuppressionFilteringParameters.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SuppressionFilteringParameters = exports.SuppressionOrigin = exports.SuppressionReason = void 0;
var FilteringParameters_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/FilteringParameters.js [app-rsc] (ecmascript)");
var SuppressionReason;
(function(SuppressionReason) {
    SuppressionReason["HardBounce"] = "HardBounce";
    SuppressionReason["SpamComplaint"] = "SpamComplaint";
    SuppressionReason["ManualSuppression"] = "ManualSuppression";
})(SuppressionReason = exports.SuppressionReason || (exports.SuppressionReason = {}));
var SuppressionOrigin;
(function(SuppressionOrigin) {
    SuppressionOrigin["Recipient"] = "Recipient";
    SuppressionOrigin["Customer"] = "Customer";
    SuppressionOrigin["Admin"] = "Admin";
})(SuppressionOrigin = exports.SuppressionOrigin || (exports.SuppressionOrigin = {}));
/**
 * Describes filtering parameters that can be used when retrieving bounces.
 * When pagination parameters are not specified, default values are set.
 */ var SuppressionFilteringParameters = function(_super) {
    __extends(SuppressionFilteringParameters, _super);
    function SuppressionFilteringParameters(count, offset, suppressionReason, origin, emailAddress, fromDate, toDate) {
        if (count === void 0) {
            count = 100;
        }
        if (offset === void 0) {
            offset = 0;
        }
        var _this = _super.call(this, count, offset) || this;
        _this.suppressionReason = suppressionReason;
        _this.origin = origin;
        _this.emailAddress = emailAddress;
        _this.fromDate = fromDate;
        _this.toDate = toDate;
        return _this;
    }
    return SuppressionFilteringParameters;
}(FilteringParameters_1.FilteringParameters);
exports.SuppressionFilteringParameters = SuppressionFilteringParameters; //# sourceMappingURL=SuppressionFilteringParameters.js.map
}),
"[project]/node_modules/postmark/dist/client/models/streams/MessageStream.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CreateMessageStreamRequest = exports.UpdateMessageStreamRequest = exports.UnsubscribeHandlingTypes = void 0;
var UnsubscribeHandlingTypes;
(function(UnsubscribeHandlingTypes) {
    UnsubscribeHandlingTypes["None"] = "None";
    UnsubscribeHandlingTypes["Postmark"] = "Postmark";
    UnsubscribeHandlingTypes["Custom"] = "Custom";
})(UnsubscribeHandlingTypes = exports.UnsubscribeHandlingTypes || (exports.UnsubscribeHandlingTypes = {}));
var UpdateMessageStreamRequest = function() {
    function UpdateMessageStreamRequest(name, description, subscriptionManagementConfiguration) {
        this.Name = name;
        this.Description = description;
        this.SubscriptionManagementConfiguration = subscriptionManagementConfiguration;
    }
    return UpdateMessageStreamRequest;
}();
exports.UpdateMessageStreamRequest = UpdateMessageStreamRequest;
var CreateMessageStreamRequest = function() {
    function CreateMessageStreamRequest(id, name, messageStreamType, description, subscriptionManagementConfiguration) {
        this.Name = name;
        this.Description = description;
        this.ID = id;
        this.MessageStreamType = messageStreamType;
        this.SubscriptionManagementConfiguration = subscriptionManagementConfiguration;
    }
    return CreateMessageStreamRequest;
}();
exports.CreateMessageStreamRequest = CreateMessageStreamRequest; //# sourceMappingURL=MessageStream.js.map
}),
"[project]/node_modules/postmark/dist/client/models/streams/MessageStreamsFilteringParameters.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MessageStreamsFilteringParameters = void 0;
/**
 * Describes filtering parameters that can be used when retrieving message streams.
 */ var MessageStreamsFilteringParameters = function() {
    function MessageStreamsFilteringParameters(messageStreamType, includeArchivedStreams) {
        this.messageStreamType = messageStreamType;
        this.includeArchivedStreams = includeArchivedStreams;
    }
    return MessageStreamsFilteringParameters;
}();
exports.MessageStreamsFilteringParameters = MessageStreamsFilteringParameters; //# sourceMappingURL=MessageStreamsFilteringParameters.js.map
}),
"[project]/node_modules/postmark/dist/client/models/data_removal/DataRemovals.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataRemovalRequest = exports.DataRemovalStatusTypes = void 0;
var DataRemovalStatusTypes;
(function(DataRemovalStatusTypes) {
    DataRemovalStatusTypes["Pending"] = "Pending";
    DataRemovalStatusTypes["Done"] = "Done";
})(DataRemovalStatusTypes = exports.DataRemovalStatusTypes || (exports.DataRemovalStatusTypes = {}));
var DataRemovalRequest = function() {
    function DataRemovalRequest(requestedBy, requestedFor, notifyWhenCompleted) {
        this.RequestedBy = requestedBy;
        this.RequestedFor = requestedFor;
        this.NotifyWhenCompleted = notifyWhenCompleted;
    }
    return DataRemovalRequest;
}();
exports.DataRemovalRequest = DataRemovalRequest; //# sourceMappingURL=DataRemovals.js.map
}),
"[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/ClientOptions.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/SupportingTypes.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/HttpClient.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/Callback.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/DefaultResponse.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/client/FilteringParameters.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/bounces/Bounce.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/bounces/BounceFilteringParameters.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/message/Message.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/message/SupportingTypes.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/messages/OutboundMessage.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/messages/OutboundMessageOpen.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/messages/OutboundMessageClick.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/messages/InboundMessage.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/messages/MessageFilteringParameters.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/templates/Template.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/server/Server.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/server/Servers.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/server/ServerFilteringParameters.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/domains/Domain.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/senders/Signature.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/suppressions/Suppression.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/stats/Stats.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/stats/StatsFilteringParameters.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/triggers/InboundRule.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/webhooks/Webhooks.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/webhooks/Webhook.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/webhooks/WebhookFilteringParameters.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/webhooks/payload/BounceWebhook.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/webhooks/payload/DeliveryWebhook.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/webhooks/payload/SpamComplaintWebhook.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/webhooks/payload/ClickWebhook.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/webhooks/payload/OpenWebhook.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/webhooks/payload/SubscriptionChangeWebhook.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/webhooks/payload/InboundWebhook.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/suppressions/Suppression.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/suppressions/SuppressionFilteringParameters.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/streams/MessageStream.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/streams/MessageStreamsFilteringParameters.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/data_removal/DataRemovals.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/postmark/dist/client/errors/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/errors/ErrorHandler.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/postmark/dist/client/errors/Errors.js [app-rsc] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/postmark/dist/client/HttpClient.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__assign || function() {
    __assign = Object.assign || function(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AxiosHttpClient = void 0;
var axios_1 = __turbopack_context__.r("[project]/node_modules/axios/dist/node/axios.cjs [app-rsc] (ecmascript)");
var models_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)");
var index_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/errors/index.js [app-rsc] (ecmascript)");
var AxiosHttpClient = function(_super) {
    __extends(AxiosHttpClient, _super);
    function AxiosHttpClient(configOptions) {
        var _this = _super.call(this, configOptions) || this;
        _this.errorHandler = new index_1.ErrorHandler();
        return _this;
    }
    /**
     * Create http client instance with default settings.
     *
     * @return {AxiosInstance}
     */ AxiosHttpClient.prototype.initHttpClient = function(configOptions) {
        this.clientOptions = __assign(__assign({}, models_1.HttpClient.DefaultOptions), configOptions);
        var httpClient = axios_1.default.create({
            baseURL: this.getBaseHttpRequestURL(),
            timeout: this.getRequestTimeoutInMilliseconds(),
            responseType: "json",
            maxContentLength: Infinity,
            maxBodyLength: Infinity,
            validateStatus: function(status) {
                return status >= 200 && status < 300;
            }
        });
        httpClient.interceptors.response.use(function(response) {
            return response.data;
        });
        this.client = httpClient;
    };
    /**
     * Process http request.
     *
     * @param method - Which type of http request will be executed.
     * @param path - API URL endpoint.
     * @param queryParameters - Querystring parameters used for http request.
     * @param body - Data sent with http request.
     */ AxiosHttpClient.prototype.httpRequest = function(method, path, queryParameters, body, requestHeaders) {
        var _this = this;
        return this.client.request({
            method: method,
            url: path,
            data: body,
            headers: requestHeaders,
            params: queryParameters
        }).catch(function(errorThrown) {
            return Promise.reject(_this.transformError(errorThrown));
        });
    };
    /**
     * Process callback function for HTTP request.
     *
     * @param error - request error that needs to be transformed to proper Postmark error.
     *
     * @return {PostmarkError} - formatted Postmark error
     */ AxiosHttpClient.prototype.transformError = function(errorThrown) {
        var response = errorThrown.response;
        if (response !== undefined) {
            var status_1 = this.adjustValue(0, response.status);
            var errorCode = this.adjustValue(0, response.data.ErrorCode);
            var message = this.adjustValue(errorThrown.message, response.data.Message);
            return this.errorHandler.buildError(message, errorCode, status_1);
        } else if (errorThrown.message !== undefined) {
            return this.errorHandler.buildError(errorThrown.message);
        } else {
            return this.errorHandler.buildError(JSON.stringify(errorThrown, Object.getOwnPropertyNames(errorThrown)));
        }
    };
    /**
     * Timeout in seconds is adjusted to Axios format.
     *
     * @private
     */ AxiosHttpClient.prototype.getRequestTimeoutInMilliseconds = function() {
        return (this.clientOptions.timeout || 60) * 1000;
    };
    AxiosHttpClient.prototype.adjustValue = function(defaultValue, data) {
        return data === undefined ? defaultValue : data;
    };
    return AxiosHttpClient;
}(models_1.HttpClient);
exports.AxiosHttpClient = AxiosHttpClient; //# sourceMappingURL=HttpClient.js.map
}),
"[project]/node_modules/postmark/package.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"name":"postmark","description":"Official Node.js client library for the Postmark HTTP API - https://www.postmarkapp.com","license":"MIT","tags":["email","utility","postmark","sending","transactional"],"version":"4.0.5","author":"Igor Balos","contributors":["Igor Balos","Andrew Theken","Aaron Blum","Aleksey Aleksandrov","Alex Shepard","Antony Jones","Ben Burwell","Ben Williamson","Chris Williams","Jakub Borys","Mark Nguyen","Matt","Matthew Blackshaw","Matthew Conlen","Ryan Kirkman","Scott Anderson","Sebastien Chopin","Theophane RUPIN","codesplicer","francescoRubini","Matthew Reff"],"main":"./dist/index.js","types":"./dist/index.d.ts","directories":{"lib":"./dist/index.js"},"scripts":{"compile":"rm -r -f ./dist && node_modules/.bin/tsc","test":"node_modules/.bin/mocha --timeout 30000 --retries 1 -r ts-node/register test/**/*test.ts","unittest":"node_modules/.bin/mocha --timeout 30000 --retries 1 -r ts-node/register test/unit/**/*test.ts","watchtests":"node_modules/.bin/mocha --timeout 30000 --retries 1 -r ts-node/register -R list -w --recursive -G test/**/*test.ts","lint":"npx eslint src --ext ts --ignore-pattern 'src/*test*'; exit 0","lintfix":"npx eslint src --ext ts --fix --ignore-pattern 'src/test*.ts'; exit 0","compile-docs":"echo 'Generating docs...' && mkdir -p ./docs && rm -r ./docs && node_modules/.bin/typedoc --options typedoc.json && git add -A ./docs && echo 'Generated docs!'"},"homepage":"http://ActiveCampaign.github.io/postmark.js","repository":{"type":"git","url":"https://github.com/ActiveCampaign/postmark.js.git"},"bugs":{"url":"https://github.com/ActiveCampaign/postmark.js/issues"},"precommit":["compile","lint","test","compile-docs"],"devDependencies":{"@types/chai":"^4.3.11","@types/mocha":"^10.0.6","@types/node":"^12.12.6","@types/sinon":"^17.0.2","@typescript-eslint/eslint-plugin":"^5.40.1","@typescript-eslint/parser":"^5.40.1","chai":"^4.3.10","dotenv":"^16.3.1","eslint":"^8.54.0","mocha":"^10.2.0","pre-commit":"^1.2.2","sinon":"^17.0.1","ts-node":"^10.9.1","typedoc":"^0.25.4","typescript":"^4.7.4"},"dependencies":{"axios":"^1.7.4"}});}),
"[project]/node_modules/postmark/dist/client/BaseClient.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
var ErrorHandler_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/errors/ErrorHandler.js [app-rsc] (ecmascript)");
var HttpClient_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/HttpClient.js [app-rsc] (ecmascript)");
var packageJson = __turbopack_context__.r("[project]/node_modules/postmark/package.json (json)");
var CLIENT_VERSION = packageJson.version;
/**
 * Base client class from which client classes can be implemented, in our case, AccountClient and ServerClient classes.
 * This class is NOT intended to be instantiated directly.
 */ var BaseClient = function() {
    function BaseClient(token, authHeader, configOptions) {
        this.errorHandler = new ErrorHandler_1.ErrorHandler();
        this.verifyToken(token);
        this.token = token.trim();
        this.authHeader = authHeader;
        this.clientVersion = CLIENT_VERSION;
        this.httpClient = new HttpClient_1.AxiosHttpClient(configOptions);
    }
    BaseClient.prototype.setClientOptions = function(configOptions) {
        this.httpClient.initHttpClient(configOptions);
    };
    BaseClient.prototype.getClientOptions = function() {
        return this.httpClient.clientOptions;
    };
    /**
     * Process http request with sending body - data.
     *
     * @see processRequest for more details.
     */ BaseClient.prototype.processRequestWithBody = function(method, path, body, callback) {
        return this.processRequest(method, path, {}, body, callback);
    };
    /**
     * Process http request without sending body - data.
     *
     * @see processRequest for more details.
     */ BaseClient.prototype.processRequestWithoutBody = function(method, path, queryParameters, callback) {
        if (queryParameters === void 0) {
            queryParameters = {};
        }
        return this.processRequest(method, path, queryParameters, null, callback);
    };
    /**
     * Process request for Postmark ClientOptions.
     *
     * @param method - see processHttpRequest for details
     * @param path - see processHttpRequest for details
     * @param queryParameters - see processHttpRequest for details
     * @param body - see processHttpRequest for details
     * @param callback - callback function to be executed.
     *
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ BaseClient.prototype.processRequest = function(method, path, queryParameters, body, callback) {
        var httpRequest = this.processHttpRequest(method, path, queryParameters, body);
        this.processCallbackRequest(httpRequest, callback);
        return httpRequest;
    };
    /**
     * Process HTTP request.
     *
     * @param method - Which type of http request will be executed.
     * @param path - API URL endpoint.
     * @param queryParameters - Querystring parameters used for http request.
     * @param body - Data sent with http request.
     *
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ BaseClient.prototype.processHttpRequest = function(method, path, queryParameters, body) {
        return this.httpClient.httpRequest(method, path, queryParameters, body, this.getComposedHttpRequestHeaders()).then(function(response) {
            return response;
        }).catch(function(error) {
            return Promise.reject(error);
        });
    };
    /**
     * Process callback function for HTTP request.
     *
     * @param httpRequest - HTTP request for which callback will be executed
     * @param callback - callback function to be executed.
     */ BaseClient.prototype.processCallbackRequest = function(httpRequest, callback) {
        if (callback) {
            httpRequest.then(function(response) {
                return callback(null, response);
            }).catch(function(error) {
                return callback(error, null);
            });
        }
    };
    /**
     * JSON object with default headers sent by HTTP request.
     */ BaseClient.prototype.getComposedHttpRequestHeaders = function() {
        var _a;
        return _a = {}, _a[this.authHeader] = this.token, _a["Accept"] = "application/json", _a["Content-Type"] = "application/json", _a["User-Agent"] = "Postmark.JS - ".concat(this.clientVersion), _a;
    };
    /**
     * Token can't be empty.
     *
     * @param {string} token - HTTP request token
     */ BaseClient.prototype.verifyToken = function(token) {
        if (!token || token.trim() === "") {
            throw this.errorHandler.buildError("A valid API token must be provided.");
        }
    };
    /**
     * Set default values for count and offset when doing filtering with API requests if they are not specified by filter.
     */ BaseClient.prototype.setDefaultPaginationValues = function(filter) {
        filter.count = filter.count || 100;
        filter.offset = filter.offset || 0;
    };
    return BaseClient;
}();
exports.default = BaseClient; //# sourceMappingURL=BaseClient.js.map
}),
"[project]/node_modules/postmark/dist/client/AccountClient.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
var BaseClient_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/BaseClient.js [app-rsc] (ecmascript)");
var models_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)");
var models_2 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)");
var AccountClient = function(_super) {
    __extends(AccountClient, _super);
    /**
     * Create a new AccountClient
     * @param accountToken The account token that should be used with requests.
     * @param configOptions Various options to customize client behavior.
     */ function AccountClient(accountToken, configOptions) {
        return _super.call(this, accountToken, models_1.ClientOptions.AuthHeaderNames.ACCOUNT_TOKEN, configOptions) || this;
    }
    /**
     * Retrieve a list of Servers.
     *
     * @param filter - An optional filter for which data is retrieved.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getServers = function(filter, callback) {
        if (filter === void 0) {
            filter = new models_2.ServerFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/servers", filter, callback);
    };
    /**
     * Retrieve a single server by ID.
     *
     * @param id - The ID of the Server for which you wish to retrieve details.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getServer = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/servers/".concat(id), {}, callback);
    };
    /**
     * Create a new Server.
     *
     * @param options - The options to be used to create new Server.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.createServer = function(options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/servers", options, callback);
    };
    /**
     * Modify the Server associated with this Client.
     *
     * @param id - The ID of the Server you wish to update.
     * @param options - The options to be used to create new Server.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.editServer = function(id, options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/servers/".concat(id), options, callback);
    };
    /**
     * Modify the Server associated with this Client.
     *
     * @param id - The ID of the Domain you wish to delete.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.deleteServer = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.DELETE, "/servers/".concat(id), {}, callback);
    };
    /**
     * Retrieve a batch of Domains.
     *
     * @param filter - An optional filter for which data is retrieved.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getDomains = function(filter, callback) {
        if (filter === void 0) {
            filter = new models_1.FilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/domains", filter, callback);
    };
    /**
     * Retrieve a single Domain by ID.
     *
     * @param id - The ID of the Domain for which you wish to retrieve details.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getDomain = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/domains/".concat(id), {}, callback);
    };
    /**
     * Create a new Domain.
     *
     * @param options - The options to be used to create new Domain.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.createDomain = function(options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/domains/", options, callback);
    };
    /**
     * Update a Domain.
     *
     * @param id - The ID of the Domain you wish to update.
     * @param domain - The values on the Domain you wish to update.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.editDomain = function(id, options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id), options, callback);
    };
    /**
     * Delete a Domain.
     *
     * @param id - The ID of the Domain you wish to delete.
     * @param options - The options to be used in create Domain.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.deleteDomain = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.DELETE, "/domains/".concat(id), {}, callback);
    };
    /**
     * Trigger Domain DKIM key verification.
     *
     * @param id - The ID of the Domain you wish to trigger DKIM verification for.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.verifyDomainDKIM = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id, "/verifyDKIM"), {}, callback);
    };
    /**
     * Trigger Domain DKIM key verification.
     *
     * @param id - The ID of the Domain you wish to trigger DKIM verification for.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.verifyDomainReturnPath = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.PUT, "/domains/".concat(id, "/verifyReturnPath"), {}, callback);
    };
    /**
     * Trigger Domain DKIM key verification.
     *
     * @param id - The ID of the Domain you wish to trigger DKIM verification for.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.verifyDomainSPF = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/domains/".concat(id, "/verifySPF"), {}, callback);
    };
    /**
     * Trigger Domain DKIM key verification.
     *
     * @param id - The ID of the Domain you wish to trigger DKIM verification for.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.rotateDomainDKIM = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/domains/".concat(id, "/rotateDKIM"), {}, callback);
    };
    /**
     * Retrieve a single Sender Signature by ID.
     *
     * @param id - The ID of the Sender Signature for which you wish to retrieve details.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getSenderSignature = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/senders/".concat(id), {}, callback);
    };
    /**
     * Retrieve a batch of Sender Signatures.
     *
     * @param filter - An optional filter for which data is retrieved.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getSenderSignatures = function(filter, callback) {
        if (filter === void 0) {
            filter = new models_1.FilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/senders", filter, callback);
    };
    /**
     * Create a new Sender Signature.
     *
     * @param options - The options to be used to create new Sender Signature.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.createSenderSignature = function(options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/senders/", options, callback);
    };
    /**
     * Update a Sender Signature.
     *
     * @param id - The ID of the Sender Signature for which you wish to update.
     * @param options - The values on the Sender Signature you wish to update.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.editSenderSignature = function(id, options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/senders/".concat(id), options, callback);
    };
    /**
     * Delete a Domain.
     *
     * @param id - The ID of the Domain you wish to delete.
     * @param options - The options to be used in create Domain.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.deleteSenderSignature = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.DELETE, "/senders/".concat(id), {}, callback);
    };
    /**
     * Request a new confirmation email to be sent to the email address associated with a Sender Signature.
     *
     * @param id - The ID of the Sender Signature.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.resendSenderSignatureConfirmation = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/senders/".concat(id, "/resend"), {}, callback);
    };
    /**
     * Request that the SPF records for Sender Signature be verified.
     *
     * @param id - The ID of the Sender Signature.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.verifySenderSignatureSPF = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/senders/".concat(id, "/verifySpf"), {}, callback);
    };
    /**
     * Request that the SPF records for Sender Signature be verified.
     *
     * @param id - The ID of the Sender Signature.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.requestNewDKIMForSenderSignature = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.POST, "/senders/".concat(id, "/requestNewDkim"), {}, callback);
    };
    /**
     * Request a push of templates from one server to another.
     *
     * @param options - details for pushing templates from one place to another.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.pushTemplates = function(options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.PUT, "/templates/push", options, callback);
    };
    /**
     * Request a data removal.
     *
     * @param options - details for creating data removal request
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.requestDataRemoval = function(options, callback) {
        return this.processRequestWithBody(models_1.ClientOptions.HttpMethod.POST, "/data-removals", options, callback);
    };
    /**
     * Retrieve a single data removal status by ID.
     *
     * @param id - The ID of the DataRemoval for which you wish to retrieve details.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ AccountClient.prototype.getDataRemovalStatus = function(id, callback) {
        return this.processRequestWithoutBody(models_1.ClientOptions.HttpMethod.GET, "/data-removals/".concat(id), {}, callback);
    };
    return AccountClient;
}(BaseClient_1.default);
exports.default = AccountClient; //# sourceMappingURL=AccountClient.js.map
}),
"[project]/node_modules/postmark/dist/client/ServerClient.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __extends = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
var BaseClient_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/BaseClient.js [app-rsc] (ecmascript)");
var index_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)");
var index_2 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)");
/**
 * Server client class that can be used to interact with an individual Postmark Server.
 */ var ServerClient = function(_super) {
    __extends(ServerClient, _super);
    /**
     * Create a client.
     *
     * @param serverToken - The token for the server that you wish to interact with.
     * @param configOptions - Options to customize the behavior of the this client.
     */ function ServerClient(serverToken, configOptions) {
        return _super.call(this, serverToken, index_1.ClientOptions.AuthHeaderNames.SERVER_TOKEN, configOptions) || this;
    }
    /** Send a single email message.
     *
     * @param email - Email message to send.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.sendEmail = function(email, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email", email, callback);
    };
    /**
     * Send a batch of email messages.
     *
     * @param emails - An array of messages to send.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.sendEmailBatch = function(emails, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email/batch", emails, callback);
    };
    /**
     * Send a message using a template.
     *
     * @param template - Message you wish to send.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.sendEmailWithTemplate = function(template, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email/withTemplate", template, callback);
    };
    /**
     * Send a batch of template email messages.
     *
     * @param templates - An array of templated messages you wish to send using this Client.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.sendEmailBatchWithTemplates = function(templates, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/email/batchWithTemplates", {
            Messages: templates
        }, callback);
    };
    /**
     * Get bounce statistic information for the associated Server.
     *
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getDeliveryStatistics = function(callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/deliveryStats", {}, callback);
    };
    /**
     * Get a batch of bounces.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getBounces = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.BounceFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/bounces", filter, callback);
    };
    /**
     * Get details for a specific Bounce.
     *
     * @param id - The ID of the Bounce you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getBounce = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/bounces/".concat(id), {}, callback);
    };
    /**
     * Get a Bounce Dump for a specific Bounce.
     *
     * @param id - The ID of the Bounce for which you wish to retrieve Bounce Dump.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getBounceDump = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/bounces/".concat(id, "/dump"), {}, callback);
    };
    /**
     * Activate email address that was deactivated due to a Bounce.
     *
     * @param id - The ID of the Bounce for which you wish to activate the associated email.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.activateBounce = function(id, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/bounces/".concat(id, "/activate"), {}, callback);
    };
    /**
     * Get the list of templates associated with this server.
     *
     * @param filter - Optional filtering options.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getTemplates = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.TemplateFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/templates", filter, callback);
    };
    /**
     * Get the a specific template associated with this server.
     *
     * @param idOrAlias - ID or alias for the template you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getTemplate = function(idOrAlias, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/templates/".concat(idOrAlias), {}, callback);
    };
    /**
     * Delete a template associated with this server.
     *
     * @param idOrAlias - ID or template alias you wish to delete.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.deleteTemplate = function(idOrAlias, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.DELETE, "/templates/".concat(idOrAlias), {}, callback);
    };
    /**
     * Create a new template on the associated server.
     *
     * @param options - Configuration options to be used to create the Template.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.createTemplate = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/templates/", options, callback);
    };
    /**
     * Update a template on the associated server.
     *
     * @param idOrAlias - Id or alias of the template you wish to update.
     * @param options - Template options you wish to update.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.editTemplate = function(idOrAlias, options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/templates/".concat(idOrAlias), options, callback);
    };
    /**
     * Validate template markup to verify that it will be parsed. Also provides a recommended template
     * model to be used when sending using the specified template content.
     *
     * @param options - The template content you wish to validate.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.validateTemplate = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/templates/validate", options, callback);
    };
    /**
     * Get the information for the Server associated with this Client.
     *
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getServer = function(callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/server", {}, callback);
    };
    /**
     * Modify the Server associated with this Client.
     *
     * @param options - The options you wish to modify.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.editServer = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/server", options, callback);
    };
    /**
     * Get a batch of Outbound Messages.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getOutboundMessages = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.OutboundMessagesFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound", filter, callback);
    };
    /**
     * Get details for a specific Outbound Message.
     *
     * @param messageId - The ID of the OutboundMessage you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getOutboundMessageDetails = function(messageId, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/".concat(messageId), {}, callback);
    };
    /**
     * Get details for a specific Outbound Message.
     *
     * @param messageId - The ID of the OutboundMessage you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getOutboundMessageDump = function(messageId, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/".concat(messageId, "/dump"), {}, callback);
    };
    /**
     * Get a batch of Inbound Messages.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getInboundMessages = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.InboundMessagesFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/inbound", filter, callback);
    };
    /**
     * Get details for a specific Inbound Message.
     *
     * @param messageId - The ID of the Inbound Message you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getInboundMessageDetails = function(messageId, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/inbound/".concat(messageId, "/details"), {}, callback);
    };
    /**
     * Cause an Inbound Message to bypass filtering rules defined on this Client's associated Server.
     *
     * @param messageId - The ID of the Inbound Message for which you wish to bypass the filtering rules.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.bypassBlockedInboundMessage = function(messageId, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.PUT, "/messages/inbound/".concat(messageId, "/bypass"), {}, callback);
    };
    /**
     * Request that Postmark retry POSTing to the Inbound Hook for the specified message.
     *
     * @param messageId - The ID of the Inbound Message for which you wish to retry the inbound hook.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.retryInboundHookForMessage = function(messageId, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.PUT, "/messages/inbound/".concat(messageId, "/retry"), {}, callback);
    };
    /**
     * Get the Opens for Outbound Messages.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageOpens = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.OutboundMessageOpensFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/opens", filter, callback);
    };
    /**
     * Get details of Opens for specific Outbound Message.
     *
     * @param messageId - Message ID of the message for which you wish to retrieve Opens.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageOpensForSingleMessage = function(messageId, filter, callback) {
        if (filter === void 0) {
            filter = new index_2.OutboundMessageOpensFilteringParameters(50, 0);
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/opens/".concat(messageId), filter, callback);
    };
    /**
     * Get the Clicks for Outbound Messages.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageClicks = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.OutboundMessageClicksFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/clicks", filter, callback);
    };
    /**
     * Get Click information for a single Outbound Message.
     *
     * @param messageId - The MessageID for which clicks should be retrieved.
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageClicksForSingleMessage = function(messageId, filter, callback) {
        if (filter === void 0) {
            filter = new index_2.OutboundMessageClicksFilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/messages/outbound/clicks/".concat(messageId), filter, callback);
    };
    /**
     * Get overview statistics on Outbound Messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getOutboundOverview = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound", filter, callback);
    };
    /**
     * Get statistics on email sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getSentCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/sends", filter, callback);
    };
    /**
     * Get statistiscs on emails that bounced after being sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getBounceCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/bounces", filter, callback);
    };
    /**
     * Get SPAM complaint statistics for email sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getSpamComplaintsCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/spam", filter, callback);
    };
    /**
     * Get email tracking statistics for messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getTrackedEmailCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/tracked", filter, callback);
    };
    /**
     * Get Open statistics for messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getEmailOpenCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens", filter, callback);
    };
    /**
     * Get Email Client Platform statistics for messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getEmailOpenPlatformUsage = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens/platforms", filter, callback);
    };
    /**
     * Get statistics on which Email Clients were used to open messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getEmailOpenClientUsage = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens/emailClients", filter, callback);
    };
    /**
     * Get Read Time statistics for messages sent from the Server associated with this Client.
     * @param filter Optional filtering parameters.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getEmailOpenReadTimes = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/opens/readTimes", filter, callback);
    };
    /**
     * Get total clicks statistics for tracked links for messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getClickCounts = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks", filter, callback);
    };
    /**
     * Get browser family statistics for tracked links for messages sent from the Server associated with this Client.
     * @param filter Optional filtering parameters.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getClickBrowserUsage = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks/browserFamilies", filter, callback);
    };
    /**
     * Get browser platform statistics for tracked links for messages sent from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getClickPlatformUsage = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks/platforms", filter, callback);
    };
    /**
     * Get click location (in HTML or Text body of the email) statistics for tracked links for messages sent
     * from the Server associated with this Client.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getClickLocation = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_2.StatisticsFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/stats/outbound/clicks/location", filter, callback);
    };
    /**
     * Create an Inbound Rule Trigger.
     *
     * @param options - Configuration options to be used when creating this Trigger.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.createInboundRuleTrigger = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/triggers/inboundRules", options, callback);
    };
    /**
     * Delete an Inbound Rule Trigger.
     *
     * @param id - The ID of the Inbound Rule Trigger you wish to delete.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.deleteInboundRuleTrigger = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.DELETE, "/triggers/inboundRules/".concat(id), {}, callback);
    };
    /**
     * Get a list of Inbound Rule Triggers.
     *
     * @param filter - Optional filtering parameters.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getInboundRuleTriggers = function(filter, callback) {
        if (filter === void 0) {
            filter = new index_1.FilteringParameters();
        }
        this.setDefaultPaginationValues(filter);
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/triggers/inboundRules", filter, callback);
    };
    /**
     * Get the list of Webhooks for specific server.
     *
     * @param filter - Optional filtering parameters
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getWebhooks = function(filter, callback) {
        if (filter === void 0) {
            filter = {};
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/webhooks", filter, callback);
    };
    /**
     * Get details for a specific Webhook.
     *
     * @param id - The ID of the Webhook you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getWebhook = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/webhooks/".concat(id), {}, callback);
    };
    /**
     * Create a Webhook on the associated server.
     *
     * @param options - Configuration options to be used when creating Webhook trigger.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.createWebhook = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/webhooks", options, callback);
    };
    /**
     * Update Webhook on the associated server.
     *
     * @param id - Id of the webhook you wish to update.
     * @param options - Webhook options you wish to update.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.editWebhook = function(id, options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PUT, "/webhooks/".concat(id), options, callback);
    };
    /**
     * Delete an existing Webhook.
     *
     * @param id - The ID of the Webhook you wish to delete.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.deleteWebhook = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.DELETE, "/webhooks/".concat(id), {}, callback);
    };
    /**
     * Get the list of message streams on a server.
     *
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageStreams = function(filter, callback) {
        if (filter === void 0) {
            filter = {};
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/message-streams", filter, callback);
    };
    /**
     * Get details for a specific message stream on a server.
     *
     * @param id - The ID of the message stream you wish to retrieve.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getMessageStream = function(id, callback) {
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/message-streams/".concat(id), {}, callback);
    };
    /**
     * Update message stream on the associated server.
     *
     * @param id - Id of the webhook you wish to update.
     * @param options - Webhook options you wish to update.
     * @param callback If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.editMessageStream = function(id, options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.PATCH, "/message-streams/".concat(id), options, callback);
    };
    /**
     * Create a message stream on the associated server.
     *
     * @param options - Configuration options to be used when creating message stream on the server.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.createMessageStream = function(options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams", options, callback);
    };
    /**
     * Archive a message stream on the associated server.
     *
     * @param options - Configuration options to be used when creating message stream on the server.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.archiveMessageStream = function(id, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(id, "/archive"), {}, callback);
    };
    /**
     * Unarchive a message stream on the associated server.
     *
     * @param options - Configuration options to be used when creating message stream on the server.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.unarchiveMessageStream = function(id, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(id, "/unarchive"), {}, callback);
    };
    /**
     * Get the list of suppressions for a message stream on a server.
     *
     * @param messageStream - Select message stream
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.getSuppressions = function(messageStream, filter, callback) {
        if (filter === void 0) {
            filter = new index_2.SuppressionFilteringParameters();
        }
        return this.processRequestWithoutBody(index_1.ClientOptions.HttpMethod.GET, "/message-streams/".concat(messageStream, "/suppressions/dump"), filter, callback);
    };
    /**
     * Add email addresses to a suppressions list on a message stream on a server.
     *
     * @param messageStream - Select message stream
     * @param options - Suppressions you wish to add.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.createSuppressions = function(messageStream, options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(messageStream, "/suppressions"), options, callback);
    };
    /**
     * Delete email addresses from a suppressions list on a message stream on a server.
     *
     * @param messageStream - Select message stream
     * @param options - Suppressions you wish to delete.
     * @param callback - If the callback is provided, it will be passed to the resulting promise as a continuation.
     * @returns A promise that will complete when the API responds (or an error occurs).
     */ ServerClient.prototype.deleteSuppressions = function(messageStream, options, callback) {
        return this.processRequestWithBody(index_1.ClientOptions.HttpMethod.POST, "/message-streams/".concat(messageStream, "/suppressions/delete"), options, callback);
    };
    return ServerClient;
}(BaseClient_1.default);
exports.default = ServerClient; //# sourceMappingURL=ServerClient.js.map
}),
"[project]/node_modules/postmark/dist/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Header = exports.Attachment = exports.TemplatedMessage = exports.Message = exports.Errors = exports.Models = exports.AdminClient = exports.AccountClient = exports.Client = exports.ServerClient = void 0;
var AccountClient_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/AccountClient.js [app-rsc] (ecmascript)");
exports.AccountClient = AccountClient_1.default;
exports.AdminClient = AccountClient_1.default;
var ServerClient_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/ServerClient.js [app-rsc] (ecmascript)");
exports.ServerClient = ServerClient_1.default;
exports.Client = ServerClient_1.default;
var Models = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)");
exports.Models = Models;
var Errors = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/errors/Errors.js [app-rsc] (ecmascript)");
exports.Errors = Errors;
// Essential types are exposed directly
// to make working with common requests simpler.
var models_1 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Message", {
    enumerable: true,
    get: function() {
        return models_1.Message;
    }
});
var models_2 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "TemplatedMessage", {
    enumerable: true,
    get: function() {
        return models_2.TemplatedMessage;
    }
});
var models_3 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Attachment", {
    enumerable: true,
    get: function() {
        return models_3.Attachment;
    }
});
var models_4 = __turbopack_context__.r("[project]/node_modules/postmark/dist/client/models/index.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Header", {
    enumerable: true,
    get: function() {
        return models_4.Header;
    }
}); //# sourceMappingURL=index.js.map
}),
];

//# sourceMappingURL=node_modules_postmark_678312e7._.js.map